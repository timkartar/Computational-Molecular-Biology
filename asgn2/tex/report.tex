\documentclass[a4paper,11pt]{article}
\newcommand\tab[1][0.6cm]{\hspace*{#1}}
\usepackage{mlsubmit}
\usepackage{amsmath}
\newenvironment{absolutelynopagebreak}
  {\par\nobreak\vfil\penalty0\vfilneg
   \vtop\bgroup}
  {\par\xdef\tpd{\the\prevdepth}\egroup
   \prevdepth=\tpd}
\raggedbottom

\begin{document}

\title{MATH578A Assignment 2 }
\author{Raktim Mitra \\ \small{USC ID: 1487079265\hspace{10pt} email: raktimmi@usc.edu}}
\maketitle
\initmlsubmision{1}                              					% assignment number
								{Raktim Mitra}      						           		% your name
								{150562}																		% your roll number
								
\section*{Q1. }
\textbf{normal pairwise alignment recursion}\\
\begin{align*}
 M[i,j] &= max\begin{cases}
               M[i,j-1] + g(s_1[i],\_)\\
               M[i-1,j] + g(\_,s_2[j])\\
               M[i-1,j-1] + g(s_1[i],s_2[j])
              \end{cases}
\end{align*}
Here, $g$ is the scoring matrix with relevant scoring scheme. But we cannot have less than k contiguous matches and/or mismatches. SO, if  we want to take a diagonal step, then it has to be at least k diagonal step. No new restriction on taking a insertion or deletion step. So, modified recursion steps:\\
\textbf{k-core alignment recursion}\\
\begin{align*}
 M[i,j] &= max\begin{cases}
               M[i,j-1] + g(s_1[i],\_)\text{ [$O(1)$ time]}\\
               M[i-1,j] + g(\_,s_2[j])\text{ [$O(1)$ time]}\\
               M[i-k,j-k] + \sum_{n=0}^{k-1}g(s_1[i-n],s_2[j-n]) \text{ [$O(k)$ time]}
              \end{cases}
\end{align*}
The above simply says, when we want to take a diagonal path, we have to reset previous k-1 steps to diagonal steps also. Otherwise, we cannot take a digonal path. This ensures, we have only streches of contiguous k or more sequences of match and mismatches.

Notice, this diagonal recursion does not happen for the first  $k-1$ row and $k-1$ columns. Which is expected because we can make a diagonal step in those region only if it creates a k-contiguous diagonal step which reaches outside and into the region $M[k..n,k..m]$. I.e. we will calculate those diagonal steps retrospectively when we are looking at positions further into the sequences.
so, for ($s_1[1..k-1]$ and $s_2[1..k-1]$) we have to take only horizontal or vertical steps. So, for this region,
\begin{align*}
 M[i,j] &= max\begin{cases}
               M[i,j-1] + g(s_1[i],\_)\\
               M[i-1,j] + g(\_,s_2[j])\\
              \end{cases}
\end{align*}
With the above recursive definitions, we can initialize the score matrix in the same manner as we did in normal pairwise global alignment (by taking only insertion or deletion paths for the first row and column). Now, we can apply the dynamic programming to calculate all values of M to calculate the required optimal score at $M[n,n]$. And, we can also keep the path pointers in another matrix to do traceback and construct the alignment in a straight forward manner.

Ignoring the modification for first k columns and rows, every entry of the matrix M takes O($k+2$) computation. SO, total complexity is $O((k+2)mn)$ which is $O(kmn)$.
\begin{center}
 -------------------
\end{center}

\section*{Q2.}

% \begin{center}
%  P.T.O.
% \end{center}
% 
% \begin{absolutelynopagebreak}
% {We can also construct length of longest substrings \underbar{starting} at i and formed by elements of S from D. Let, this array be B[ ]. Shown in full pseudocode below:}
% \end{absolutelynopagebreak}
% \begin{mlalgorithm}[0.9\textwidth]{H}{Multiset Matching }\vskip-2ex
% 	\label{algo:tk-means}
% 	\begin{algorithmic}[1]
% 		\REQUIRE Text T and Multiset S
% 		\STATE A $\leftarrow$ Unique(S)
% 		\STATE initialize Count[0...length(A)] to all 0
%         \STATE initialize RunningCount[0...length(A)] to all 0
% 		\FOR{element e in S}
% 		\STATE  Count[A.index[e]]++
% 		\ENDFOR 
% 		\STATE intiailize D[0...m-1]
% 		\STATE D[-1] $\leftarrow$ 0 \COMMENT{For convenience, In actual implementation we would hardcode D[0] and start the following loop at 1.}
% 		\FOR{\{i=0; i $<$ m; i++\}}
%             \IF [Case 1]{T[i] not in A } 
%             \STATE D[i] $\leftarrow$ 0 
%             \STATE \{RunningCount[j] $\leftarrow$ 0 for j in interval [0,length(a))\}
%             \ELSIF{RunningCount[A.index[T[i]] $<$ Count[A.index[T[i]]]\COMMENT{Case 2a}} 
%             \STATE D[i] $\leftarrow$ D[i-1] + 1 
%             \STATE RunningCount[A.index[T[i]]++
%             \ELSE [Case 2b]
%             \STATE j $\leftarrow$ i - D[i-1] + 1 //Case 2b
%             \WHILE{j$\leq$i and T[j] != T[i]}
%             \STATE RunningCount[A.index[T[j]]]$--$
%             \ENDWHILE
%             \STATE D[i] $\leftarrow$ i $-$ j
%             \ENDIF
% 		\ENDFOR
% 		\STATE Initialize B[0..m-1] \COMMENT{length of substrings longest substrings formed by elements of S from starting positions.}
% 		\STATE  i $\leftarrow$ 0
% 		\STATE  Initialize R \COMMENT{List of starting positions of occurences}
% 		\WHILE[O(m), only correct when i goes from 0 to m-1, the descending order of traversal won't work.]{\{i $<$ m\}} 
%             \STATE B[i - D[i]] $\leftarrow$ D[i]
%             \IF{D[i] == size(S)}
%             \STATE R.add(i - D[i])
%             \STATE i++
%             \ENDIF
%         \ENDWHILE
% 		\RETURN R, B
% 	\end{algorithmic}
% \end{mlalgorithm}


\begin{center}
 -------------------
\end{center}
\section*{Q3.}

\begin{center}
 ------------------
\end{center}
\section*{Q4.}

\begin{center}
-----------------\\
\end{center}
% 
% \section*{Q5.}
% \begin{center}
% 
%  ------------------ -----------------
% \end{center}

\end{document}
